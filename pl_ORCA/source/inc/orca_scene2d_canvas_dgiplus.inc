{%mainunit ../orca_scene2d.pas}
            
{**********************************************************************
 Package pl_ORCA.pkg
 This unit is part of CodeTyphon Studio  (http://www.pilotlogic.com/)
***********************************************************************}


type

  TD2FilterGdiPlus=class(TD2Filter)
  private
  public
  published
    class function GetFileTypes:string;  override;
    class function GetImageSize(const AFileName:string):TD2Point;  override;
    function LoadFromFile(const AFileName:string; const Rotate:single; var Bitmap:TD2Bitmap):boolean;  override;
    function SaveToFile(const AFileName:string; var Bitmap:TD2Bitmap; const Params:string=''):boolean;  override;
    function LoadFromStream(const AStream:TStream; var Bitmap:TD2Bitmap):boolean;  override;
    function SaveToStream(const AStream:TStream; var Bitmap:TD2Bitmap; const Format:string;
                          const Params:string=''):boolean;  override;
    function LoadThumbnailFromFile(const AFileName:string; const AFitWidth,AFitHeight:single; const UseEmbedded:boolean;
                                   var Bitmap:TD2Bitmap):boolean;  override;
  end;

  TD2CanvasGdiPlus=class(TD2Canvas)
  private
    FBufferHandle:cardinal;
    FBitmapInfo:TBitmapInfo;
    FGraphics:TGPGraphics;
    FGPPen:TGPPen;
    FGPPenBrush:TGPBrush;
    FGPBrush:TGPBrush;
    FGPFamily:TGPFontFamily;
    FFontCollection:TGPPrivateFontCollection;
    FFontScale:single;
  protected
    procedure UpdateBitmap(ABitmap:TD2Bitmap); 
    procedure DestroyBitmap(Sender:TObject);
    procedure ApplyFill(ARect:TD2Rect; const AOpacity:single);
    procedure ApplyStroke(ARect:TD2Rect; const AOpacity:single);
    procedure FontChanged(Sender:TObject);  override;
    procedure IntFillPath(P:TGPGraphicsPath; R:TD2Rect; Opacity:single);
    procedure IntFillRect(R:TD2Rect; Opacity:single);
  public
    constructor Create(const AWidth,AHeight:integer);  override;
    constructor CreateFromBitmap(const ABitmap:TD2Bitmap);  override;
    destructor Destroy;  override;
    class function GetBitmapScanline(Bitmap:TD2Bitmap; y:integer):PD2ColorArray;  override;
    procedure FreeBuffer;  override;
    procedure ResizeBuffer(const AWidth,AHeight:integer);  override;
    procedure FlushBuffer(const X,Y:integer; const DC:Cardinal);  override;
    procedure FlushBufferRect(const X,Y:integer; const DC:Cardinal; const ARect:TD2Rect);  override;
    procedure Clear(const Color:cardinal);  override;
    procedure ClearRect(const ARect:TD2Rect; const AColor:TD2Color=0);  override;
    procedure SetMatrix(const M:TD2Matrix);  override;
    procedure MultyMatrix(const M:TD2Matrix);  override;
    function  SaveCanvas:cardinal;  override;
    procedure RestoreCanvas(const AState:cardinal);  override;
    procedure SetClipRects(const ARects:array of TD2Rect);  override;
    procedure IntersectClipRect(const ARect:TD2Rect);  override;
    procedure ExcludeClipRect(const ARect:TD2Rect);  override;
    procedure ResetClipRect;  override;
    procedure DrawLine(const APt1,APt2:TD2Point; const AOpacity:single);  override;
    procedure FillRect(const ARect:TD2Rect; const xRadius,yRadius:single; const ACorners:TD2Corners; const AOpacity:single;
                       const ACornerType:TD2CornerType=d2CornerRound);  override;
    procedure DrawRect(const ARect:TD2Rect; const xRadius,yRadius:single; const ACorners:TD2Corners; const AOpacity:single;
                       const ACornerType:TD2CornerType=d2CornerRound);  override;
    procedure FillEllipse(const ARect:TD2Rect; const AOpacity:single);  override;
    procedure DrawEllipse(const ARect:TD2Rect; const AOpacity:single);  override;
    function  LoadFontFromStream(AStream:TStream):boolean;  override;
    procedure FillText(const ARect,AClipRect:TD2Rect; const AText:WideString; const WordWrap:boolean;
                       const AOpacity:single; const ATextAlign:TD2TextAlign; const AVTextAlign:TD2TextAlign=d2TextAlignCenter);  override;
    procedure MeasureText(var ARect:TD2Rect; AClipRect:TD2Rect; const AText:WideString; const WordWrap:boolean; const ATextAlign:TD2TextAlign;
                          const AVTextAlign:TD2TextAlign=d2TextAlignCenter);  override;
    function  TextToPath(Path:TD2PathData; const ARect:TD2Rect; const AText:WideString; const WordWrap:boolean; const ATextAlign:TD2TextAlign;
                        const AVTextAlign:TD2TextAlign=d2TextAlignCenter):boolean;  override;
    function  PtInPath(const APoint:TD2Point; const ARect:TD2Rect; const APath:TD2PathData):boolean;  override;
    procedure FillPath(const APath:TD2PathData; const ARect:TD2Rect; const AOpacity:single);  override;
    procedure DrawPath(const APath:TD2PathData; const ARect:TD2Rect; const AOpacity:single);  override;
    procedure DrawBitmap(const ABitmap:TD2Bitmap; const SrcRect,DstRect:TD2Rect; const AOpacity:single; const HighSpeed:boolean=false);  override;
    procedure DrawThumbnail(const ABitmap:TD2Bitmap; const Width,Height:single);  override;

  end;

//==================================================================
//==================================================================


procedure InitGDIP;
begin
  if GdipLibrary <> 0 then Exit;
  LoadGdiplus;
  StartupInput.DebugEventCallback:=nil;
  StartupInput.SuppressBackgroundThread:=false;
  StartupInput.SuppressExternalCodecs  :=false;
  StartupInput.GdiplusVersion:=1;
  GdiplusStartup(gdiplusToken,@StartupInput,nil);
end;

procedure FreeGDIP;
begin
  if GdipLibrary=0 then Exit;
  if assigned(GenericSansSerifFontFamily) then GenericSansSerifFontFamily.Free;
  if assigned(GenericSerifFontFamily) then GenericSerifFontFamily.Free;
  if assigned(GenericMonospaceFontFamily) then GenericMonospaceFontFamily.Free;
  if assigned(GenericTypographicStringFormatBuffer) then GenericTypographicStringFormatBuffer.free;
  if assigned(GenericDefaultStringFormatBuffer) then GenericDefaultStringFormatBuffer.Free;
  GdiplusShutdown(gdiplusToken);
  FreeGdiplus;
end;

function GPRectFromRect(const R:TD2Rect):TGPRectF;
begin
  Result.X:=R.Left;
  Result.Y:=R.Top;
  Result.Width:=R.Right - R.Left;
  Result.Height:=R.Bottom - R.Top;
end;

function GPRectFromRectTruncated(const R:TD2Rect):TGPRectF;
begin
  Result.X:=Trunc(R.Left);
  Result.Y:=Trunc(R.Top);
  Result.Width:=Trunc(R.Right) - Trunc(R.Left);
  Result.Height:=Trunc(R.Bottom) - Trunc(R.Top);
end;

type

  TMyStreamAdapter=class(TInterfacedObject,IStream)
  public
    FStream:TStream;
    FOwnership:TStreamOwnership;
  public
    constructor Create(Stream:TStream; Ownership:TStreamOwnership=soReference);
    destructor Destroy;  override;
    function Read(pv :Pointer;cb :DWORD;pcbRead :PDWORD) :HRESULT; virtual; stdcall;
    function Write(pv :Pointer;cb :DWORD;pcbWritten :PDWORD):HRESULT; virtual; stdcall;
    //function Seek(dlibMove:Largeint; dwOrigin:Longint; out libNewPosition:Largeint):HResult; virtual; stdcall;
    //function Seek(dlibMove:QWord; dwOrigin:Longint; out libNewPosition:QWord):HResult; virtual; stdcall;
    function Seek(dlibMove: LargeInt; dwOrigin: DWORD; out libNewPosition: LargeUInt): HResult; virtual; stdcall;
    //function SetSize(libNewSize:Largeint):HResult; virtual; stdcall;
    function SetSize(libNewSize:QWord):HResult; virtual; stdcall;
    //function CopyTo(stm:IStream; cb:Largeint; out cbRead:Largeint; out cbWritten:Largeint):HResult; virtual; stdcall;
    function CopyTo(stm:IStream; cb:QWord; out cbRead:QWord; out cbWritten:QWord):HResult; virtual; stdcall;
    //function Commit(grfCommitFlags:Longint):HResult; virtual; stdcall;
    function Commit(grfCommitFlags : DWORD) : HRESULT; virtual; stdcall;

    function Revert:HResult; virtual; stdcall;
    //function LockRegion(libOffset:Largeint; cb:Largeint; dwLockType:Longint):HResult; virtual; stdcall;
    //function LockRegion(libOffset:QWord; cb:QWord; dwLockType:Longint):HResult; virtual; stdcall;
    function LockRegion(libOffset: LargeUInt; cb: LargeUInt; dwLockType: DWORD): HRESULT; virtual; stdcall;

    //function UnlockRegion(libOffset:Largeint; cb:Largeint; dwLockType:Longint):HResult; virtual; stdcall;
    //function UnlockRegion(libOffset:QWord; cb:QWord; dwLockType:Longint):HResult; virtual; stdcall;
    function UnlockRegion(libOffset:LargeUInt; cb:LargeUInt; dwLockType:DWORD): HRESULT; virtual; stdcall;

    //function Stat(out statstg:TStatStg; grfStatFlag:Longint):HResult; virtual; stdcall;
    function Stat(out statstg: TStatStg; grfStatFlag: DWORD): HRESULT; virtual; stdcall;


    function Clone(out stm:IStream):HResult; virtual; stdcall;
    property Stream:TStream read FStream;
    property StreamOwnership:TStreamOwnership read FOwnership write FOwnership;
  end;

//====================== TMyStreamAdapter =====================================

constructor TMyStreamAdapter.Create(Stream:TStream; Ownership:TStreamOwnership);
begin
  inherited Create;
  FStream:=Stream;
  FOwnership:=Ownership;
end;

destructor TMyStreamAdapter.Destroy;
begin
  if FOwnership=soOwned then
  begin
    FStream.Free;
    FStream:=nil;
  end;
  inherited Destroy;
end;

//function TMyStreamAdapter.SetSize(libNewSize:Largeint):HResult;
function TMyStreamAdapter.SetSize(libNewSize:QWord):HResult;
begin
  try
    FStream.Size:=libNewSize;
    if libNewSize <> FStream.Size then
      Result:=E_FAIL else
      Result:=S_OK;
  except
    Result:=E_UNEXPECTED;
  end;
end;

function TMyStreamAdapter.Read(pv :Pointer;cb :DWORD;pcbRead :PDWORD):HResult;
var
  xNR:DWORD;
begin
  try
    if pv=Nil then
    begin
      Result:=STG_E_INVALIDPOINTER;
      Exit;
    end;

    xNR:=FStream.Read(pv^,cb);
    if pcbRead <> Nil then pcbRead^:=xNR;
    Result:=S_OK;
  except
    Result:=S_FALSE;
  end;
end;

function TMyStreamAdapter.Write(pv :Pointer;cb :DWORD;pcbWritten :PDWORD):HResult;
var
  xNW:DWORD;
begin
  try
    if pv=Nil then
    begin
      Result:=STG_E_INVALIDPOINTER;
      Exit;
    end;
    xNW:=FStream.Write(pv^,cb);

    if pcbWritten <> Nil then pcbWritten^:=xNW;

    Result:=S_OK;
  except
    Result:=STG_E_CANTSAVE;
  end;
end;

//function TMyStreamAdapter.Commit(grfCommitFlags:Longint):HResult;
function TMyStreamAdapter.Commit(grfCommitFlags: DWORD): HRESULT;
begin
  Result:=S_OK;
end;

//function TMyStreamAdapter.LockRegion(libOffset:Largeint; cb:Largeint; dwLockType:Longint):HResult;
//function TMyStreamAdapter.LockRegion(libOffset:QWord; cb:QWord; dwLockType:Longint):HResult;
function TMyStreamAdapter.LockRegion(libOffset: LargeUInt; cb:LargeUInt; dwLockType: DWORD): HRESULT;
begin
  Result:=STG_E_INVALIDFUNCTION;
end;

//function TMyStreamAdapter.UnlockRegion(libOffset:Largeint; cb:Largeint; dwLockType:Longint):HResult;
//function TMyStreamAdapter.UnlockRegion(libOffset:QWord; cb:QWord; dwLockType:Longint):HResult;
function TMyStreamAdapter.UnlockRegion(libOffset:LargeUInt; cb:LargeUInt; dwLockType:DWORD): HRESULT;
begin
  Result:=STG_E_INVALIDFUNCTION;
end;

//function TMyStreamAdapter.Seek(dlibMove:Largeint; dwOrigin:longint; out libNewPosition:Largeint):HResult;
//function TMyStreamAdapter.Seek(dlibMove:QWord; dwOrigin:longint; out libNewPosition:QWord):HResult;
function TMyStreamAdapter.Seek(dlibMove: LargeInt; dwOrigin: DWORD; out libNewPosition: LargeUInt): HResult;
var
  xNPos:LargeInt;
begin
  try
    if (dwOrigin < STREAM_SEEK_SET) or (dwOrigin > STREAM_SEEK_END) then
    begin
      Result:=STG_E_INVALIDFUNCTION;
      Exit;
    end;
    xNPos:=FStream.Seek(dlibMove,dwOrigin);
    if @libNewPosition <> nil then libNewPosition:=xNPos;
    Result:=S_OK;
  except
    Result:=STG_E_INVALIDPOINTER;
  end;
end;


//function TMyStreamAdapter.CopyTo(stm:IStream; cb:Largeint; out cbRead:Largeint; out cbWritten:Largeint):HResult;
function TMyStreamAdapter.CopyTo(stm:IStream; cb:QWord; out cbRead:QWord; out cbWritten:QWord):HResult;
const
  MaxBufSize=1024 * 1024;
var
  Buffer:Pointer;
  BufSize,N,I,R:PtrInt;//Integer;
  BytesRead,BytesWritten,W:LargeInt;
begin
  Result:=S_OK;
  BytesRead:=0;
  BytesWritten:=0;
  try
    if cb > MaxBufSize then
      BufSize:=MaxBufSize
    else
      BufSize:=PtrInt(cb);
    GetMem(Buffer,BufSize);
    try
      while cb > 0 do
      begin
        if cb > MaxInt then
          I:=MaxInt
        else
          I:=cb;
        while I > 0 do
        begin
          if I > BufSize then N:=BufSize else N:=I;
          R:=FStream.Read(Buffer^,N);
          if R=0 then Exit;
          Inc(BytesRead,R);
          W:=0;
          Result:=stm.Write(Buffer,R,@W);
          Inc(BytesWritten,W);
          if (Result=S_OK) and (PtrInt(W) <> R) then Result:=E_FAIL;
          if Result <> S_OK then Exit;
          Dec(I,R);
          Dec(cb,R);
        end;
      end;
    finally
      FreeMem(Buffer);
      if (@cbWritten <> nil) then cbWritten:=BytesWritten;
      if (@cbRead <> nil) then cbRead:=BytesRead;
    end;
  except
    Result:=E_UNEXPECTED;
  end;
end;

function TMyStreamAdapter.Revert:HResult;
begin
  Result:=STG_E_REVERTED;
end;

function DateTimeToFileTime(FileTime:TDateTime):TFileTime;
var
  LocalFileTime,Ft:TFileTime;
  SystemTime:TSystemTime;
begin
  Result.dwLowDateTime :=0;
  Result.dwHighDateTime:=0;
  DateTimeToSystemTime(FileTime,SystemTime);
  SystemTimeToFileTime(SystemTime,LocalFileTime);
  LocalFileTimeToFileTime(LocalFileTime,Ft);
  Result:=Ft;
end;

//function TMyStreamAdapter.Stat(out statstg:TStatStg; grfStatFlag:Longint):HResult;
function TMyStreamAdapter.Stat(out statstg: TStatStg; grfStatFlag: DWORD): HRESULT;
begin
  Result:=S_OK;
  try
    if (@statstg <> nil) then
    begin
      FillChar(statstg,SizeOf(statstg),0);
      with statstg do
      begin
        dwType:=STGTY_STREAM;
        cbSize:=Stream.Size;
        mTime:=DateTimeToFileTime(now);
        cTime:=DateTimeToFileTime(now);
        aTime:=DateTimeToFileTime(now);
        grfLocksSupported:=LOCK_WRITE;
      end;
    end;
  except
    Result:=E_UNEXPECTED;
  end;
end;

function TMyStreamAdapter.Clone(out stm:IStream):HResult;
begin
  Result:=E_NOTIMPL;
end;

//==================== TD2FilterGdiPlus ===============================

class function TD2FilterGdiPlus.GetFileTypes:string;
begin
  Result:='*.bmp;*.jpg;*.jpeg;*.png;*.tif;*.tiff;*.gif;*.ico'
end;

class function TD2FilterGdiPlus.GetImageSize(const AFileName:string):TD2Point;
var
  img:TGPImage;
  S:TStream;
  adapter:TMyStreamAdapter;
begin
  S:=TFileStream.Create(AFileName,fmOpenRead or fmShareDenyNone);
  adapter:=TMyStreamAdapter.Create(S);
  try
    img:=TGPImage.Create(adapter,true);
    Result:=d2Point(img.GetWidth,img.GetHeight);
    img.Free;
  finally
    S.Free;
  end;
end;

function TD2FilterGdiPlus.LoadFromFile(const AFileName:string;
  const Rotate:single; var Bitmap:TD2Bitmap):boolean;
var
  img:TGPImage;
  bmp:TGPBitmap;
  graphics:TGPGraphics;
  M,M2:TD2Matrix;
  Pts:array [1..4] of TD2Point;
  GM:TGPMatrix;
  R:TD2Rect;
  BD:TBitmapData;
  S:TStream;
  adapter:TMyStreamAdapter;
begin
  Result:=false;
  S:=TFileStream.Create(AFileName,fmOpenRead or fmShareDenyNone);
  adapter:=TMyStreamAdapter.Create(S);
  try
    img:=TGPImage.Create(adapter,true);
    if img.GetWidth * img.GetHeight <> 0 then
    begin
      if (frac(Rotate)=0) and (Trunc(rotate) mod 90=0) then
      begin

        if (Trunc(rotate) mod 360=90) or (Trunc(rotate) mod 360=270) then
          Bitmap.SetSize(img.GetHeight,img.GetWidth)  else
          Bitmap.SetSize(img.GetWidth,img.GetHeight);

        bmp:=TGPBitmap.Create(adapter,true);
        if Trunc(rotate) mod 360=90 then    bmp.RotateFlip(Rotate90FlipNone);
        if Trunc(rotate) mod 360=180 then   bmp.RotateFlip(Rotate180FlipNone);
        if Trunc(rotate) mod 360=270 then   bmp.RotateFlip(Rotate270FlipNone);

        if bmp.LockBits(MakeRect(0,0,Bitmap.Width,Bitmap.Height),ImageLockModeRead,PixelFormat32bppPARGB,BD)=OK then
        begin
          d2MoveLongword(BD.Scan0,Bitmap.StartLine,Bitmap.Width * Bitmap.Height);
          bmp.UnlockBits(BD)
        end;
        bmp.Free;
      end
      else
      begin
        M:=IdentityMatrix;
        M.m31:=-(img.GetWidth / 2);
        M.m32:=-(img.GetHeight / 2);
        M:=d2MatrixMultiply(M,d2CreateRotationMatrix(d2DegToRad(Rotate)));

        Pts[1]:=d2PointFromVector(d2VectorTransform(d2Vector(0,0),M));
        Pts[2]:=d2PointFromVector(d2VectorTransform(d2Vector(img.GetWidth,0),M));
        Pts[3]:=d2PointFromVector(d2VectorTransform(d2Vector(img.GetWidth,img.GetHeight),M));
        Pts[4]:=d2PointFromVector(d2VectorTransform(d2Vector(0,img.GetHeight),M));
        R:=d2NormalizeRect(Pts);

        M2:=IdentityMatrix;
        M2.m31:=d2RectWidth(R) / 2;
        M2.m32:=d2RectHeight(R) / 2;
        M:=d2MatrixMultiply(M,M2);

        Bitmap.SetSize(Trunc(d2RectWidth(R)),Trunc(d2RectHeight(R)));

        bmp:=TGPBitmap.Create(Bitmap.Width,Bitmap.Height,Bitmap.Width * 4,PixelFormat32bppPARGB,PBYTE(Bitmap.StartLine));
        graphics:=TGPGraphics.Create(bmp);
        with M do
          GM:=TGPMatrix.Create(m11,m12,m21,m22,m31,m32);

        graphics.SetTransform(GM);
        GM.Free;
        graphics.DrawImage(img,0,0,img.GetWidth,img.GetHeight);
        graphics.Free;
        bmp.Free;
      end;
      Result:=true;
    end;
    img.Free;
  finally
    S.Free;
  end;
end;

function TD2FilterGdiPlus.LoadThumbnailFromFile(const AFileName:string; const AFitWidth,AFitHeight:single;
                                               const UseEmbedded:boolean; var Bitmap:TD2Bitmap):boolean;
var
  R:TD2Rect;
  thumb,img:TGPImage;
  bmp:TGPBitmap;
  xGR:TGPGraphics;
  scale:single;
  S:TStream;
  adapter:TMyStreamAdapter;
begin
  Result:=false;
  S:=TFileStream.Create(AFileName,fmOpenRead or fmShareDenyNone);
  adapter:=TMyStreamAdapter.Create(S);
  try
    img:=TGPImage.Create(adapter,true);
    if img.GetWidth * img.GetHeight <> 0 then
    begin
      R:=d2Rect(0,0,img.GetWidth,img.GetHeight);
      scale:=d2FitRect(R,d2Rect(0,0,AFitWidth,AFitHeight));
      if scale=0 then scale:=0.001;
      if scale < 1 then scale:=1;

      if UseEmbedded then
      begin
        thumb:=img.GetThumbnailImage(trunc(img.GetWidth / scale),trunc(img.GetHeight / scale));
        if thumb <> nil then
        begin
          Bitmap.SetSize(thumb.GetWidth,thumb.GetHeight);
          bmp:=TGPBitmap.Create(Bitmap.Width,Bitmap.Height,Bitmap.Width * 4,PixelFormat32bppPARGB,PBYTE(bitmap.Scanline[0]));
          xGR:=TGPGraphics.Create(bmp);
          xGR.DrawImage(thumb,0,0,Bitmap.Width,Bitmap.Height);
          xGR.Free;
          bmp.Free;
          thumb.Free;
        end;
      end else
      begin
        Bitmap.SetSize(trunc(d2RectWidth(R)),trunc(d2RectHeight(R)));
        bmp:=TGPBitmap.Create(Bitmap.Width,Bitmap.Height,Bitmap.Width * 4,PixelFormat32bppPARGB,PBYTE(bitmap.Scanline[0]));
        bmp.SetResolution(img.GetHorizontalResolution / scale,img.GetVerticalResolution / scale);
        xGR:=TGPGraphics.Create(bmp);
        xGR.SetInterpolationMode(QualityModeHigh);
        xGR.DrawImage(img,0,0);
        xGR.Free;
        bmp.Free;
      end;
      Result:=true;
    end;
    img.Free;
  finally
    S.Free;
  end;
end;

function TD2FilterGdiPlus.LoadFromStream(const AStream:TStream; var Bitmap:TD2Bitmap):boolean;
var
  img:TGPImage;
  bmp:TGPBitmap;
  xGR:TGPGraphics;
  adapter:TMyStreamAdapter;
begin
  Result:=false;
  adapter:=TMyStreamAdapter.Create(AStream);
  img:=TGPImage.Create(adapter,true);
  if img.GetWidth * img.GetHeight <> 0 then
  begin
    Bitmap.SetSize(img.GetWidth,img.GetHeight);
    bmp:=TGPBitmap.Create(Bitmap.Width,Bitmap.Height,Bitmap.Width * 4,PixelFormat32bppPARGB,PBYTE(bitmap.Scanline[0]));
    xGR:=TGPGraphics.Create(bmp);
    xGR.DrawImage(img,0,0,Bitmap.Width,Bitmap.Height);
    xGR.Free;
    bmp.Free;
    Result:=true;
  end;
  img.Free;
end;

function TD2FilterGdiPlus.SaveToStream(const AStream:TStream; var Bitmap:TD2Bitmap; const Format:string;  const Params:string=''):boolean;
var
  bmp:TGPBitmap;
  adapter:TMyStreamAdapter;
  encoderClsid:TGUID;
  encoderParameters:TEncoderParameters;
  IntValue:integer;
  S,param,name,value:ansistring;
  encoder:ansistring;
  i:integer;
begin
  encoder:='image/png';
  if LowerCase(Format)='jpeg' then encoder:='image/jpeg';
  if LowerCase(Format)='jpg' then encoder:='image/jpeg';
  if LowerCase(Format)='png' then encoder:='image/png';
  if LowerCase(Format)='bmp' then encoder:='image/bmp';
  if LowerCase(Format)='tif' then encoder:='image/tiff';
  if LowerCase(Format)='tiff' then encoder:='image/tiff';
  if LowerCase(Format)='gif' then encoder:='image/gif';

  if GetEncoderClsid(encoder,encoderClsid) >= 0 then
  begin
    adapter:=TMyStreamAdapter.Create(AStream);
    bmp:=TGPBitmap.Create(Bitmap.Width,Bitmap.Height,Bitmap.Width * 4,PixelFormat32bppPARGB,PBYTE(bitmap.Scanline[0]));

    if Params <> '' then
    begin
      S:=Params;
      i:=0;
      while S <> '' do
      begin
        param:=d2GetToken(S,' ');
        name:=d2GetToken(param,'=');
        value:=d2GetToken(param,'');
        if CompareText(name,'quality')=0 then
        begin
          encoderParameters.Parameter[i].Guid:=EncoderQuality;
          encoderParameters.Parameter[i].NumberOfValues:=1;
          encoderParameters.Parameter[i].Type_:=EncoderParameterValueTypeLong;
          IntValue:=strToInt(value);
          encoderParameters.Parameter[i].Value:=@IntValue;
        end;
        Inc(i);
      end;
      encoderParameters.Count:=i;

      bmp.Save(adapter,encoderClsid,@encoderParameters);
    end
    else
      bmp.Save(adapter,encoderClsid);
    bmp.Free;
  end;
end;

function TD2FilterGdiPlus.SaveToFile(const AFileName:string;
  var Bitmap:TD2Bitmap; const Params:string=''):boolean;
var
  S,param,name,value:ansistring;
  bmp:TGPBitmap;
  encoderClsid:TGUID;
  encoderType:ansistring;
  i,IntValue:integer;
  encoderParameters:TEncoderParameters;
begin
  encoderType:='';
  if (LowerCase(ExtractFileExt(AFileName))='.jpg') or (LowerCase(ExtractFileExt(AFileName))='.jpeg') then
    encoderType:='image/jpeg';

  if (LowerCase(ExtractFileExt(AFileName))='.bmp') then
    encoderType:='image/bmp';

  if (LowerCase(ExtractFileExt(AFileName))='.png') then
    encoderType:='image/png';

  if (LowerCase(ExtractFileExt(AFileName))='.tif') or (LowerCase(ExtractFileExt(AFileName))='.tiff') then
    encoderType:='image/tiff';

  if (LowerCase(ExtractFileExt(AFileName))='.gif') then
    encoderType:='image/gif';

  if GetEncoderClsid(encoderType,encoderClsid) >= 0 then
  begin
    bmp:=TGPBitmap.Create(Bitmap.Width,Bitmap.Height,Bitmap.Width * 4,PixelFormat32bppPARGB,PBYTE(bitmap.Scanline[0]));

    if Params <> '' then
    begin
      S:=Params;
      i:=0;
      while S <> '' do
      begin
        param:=d2GetToken(S,' ');
        name:=d2GetToken(param,'=');
        value:=d2GetToken(param,'');
        if CompareText(name,'quality')=0 then
        begin
          encoderParameters.Parameter[i].Guid:=EncoderQuality;
          encoderParameters.Parameter[i].NumberOfValues:=1;
          encoderParameters.Parameter[i].Type_:=EncoderParameterValueTypeLong;
          IntValue:=strToInt(value);
          encoderParameters.Parameter[i].Value:=@IntValue;
        end;
        Inc(i);
      end;
      encoderParameters.Count:=i;

      bmp.Save(AFileName,encoderClsid,@encoderParameters);
    end
    else
      bmp.Save(AFileName,encoderClsid);
    bmp.Free;
  end;
end;

//============================= TD2CanvasGdiPlus ======================================

const
  imgColorMatrix :TColorMatrix =
    ((1,0.0,0.0,0.0,0.0),
     (0.0,1.0,0.0,0.0,0.0),
     (0.0,0.0,1.0,0.0,0.0),
     (0.0,0.0,0.0,0.1,0.0),
     (0.0,0.0,0.0,0.0,1.0));
var
  ColorArray:array [0..100] of TGPColor;
  OffsetArray:array [0..100] of single;

function d2StyleToGPStyle(S:TD2FontStyle):integer;
begin
  case S of
    d2FontRegular:Result:=FontStyleRegular;
    d2FontBold:Result:=FontStyleBold;
    d2FontItalic:Result:=FontStyleItalic;
    d2FontBoldItalic:Result:=FontStyleBoldItalic;
    d2FontUnderline:Result:=FontStyleUnderline;
    d2FontStrikeout:Result:=FontStyleStrikeout;
  end;
end;

constructor TD2CanvasGdiPlus.Create(const AWidth,AHeight:integer);
begin
  FBuffered:=true;
  inherited ;
  FGPPen:=TGPPen.Create($FF000000);
  FGPPenBrush:=TGPSolidBrush.Create($FF000000);
  FGPBrush:=TGPSolidBrush.Create(InvalideCanvasState);
  FGPFamily:=TGPFontFamily.Create('Tahoma');
  FFontScale:=1;
end;

constructor TD2CanvasGdiPlus.CreateFromBitmap(const ABitmap:TD2Bitmap);
begin
  inherited;
  FBitmap:=ABitmap;
  UpdateBitmap(FBitmap);
  FGraphics:=TGPGraphics.Create(TGPBitmap(FBitmap.Handle));
  FGraphics.SetSmoothingMode(SmoothingModeHighQuality);
  FGraphics.SetPixelOffsetMode(PixelOffsetModeHalf);
  FGraphics.SetTextContrast(2);
  FGPPen:=TGPPen.Create($FF000000);
  FGPPenBrush:=TGPSolidBrush.Create($FF000000);
  FGPBrush:=TGPSolidBrush.Create(InvalideCanvasState);
  FGPFamily:=TGPFontFamily.Create('Tahoma');
  FFontScale:=96 / FGraphics.GetDpiX;
end;

destructor TD2CanvasGdiPlus.Destroy;
begin
  FreeAndNil(FFontCollection);
  FreeAndNil(FGraphics);
  FreeAndNil(FGPFamily);
  FreeAndNil(FGPBrush);
  FreeAndNil(FGPPenBrush);
  FreeAndNil(FGPPen);
  inherited;
end;

procedure TD2CanvasGdiPlus.FreeBuffer;
begin
  FreeAndNil(FGraphics);
  if FBuffered then
  begin
    if FBufferHandle=0 then Exit;
    if FHandle <> 0 then DeleteDC(FHandle);
    FHandle:=0;
    if FBufferHandle <> 0 then DeleteObject(FBufferHandle);
    FBufferHandle:=0;
  end;
end;

procedure TD2CanvasGdiPlus.ResizeBuffer(const AWidth,AHeight:integer);
begin
  if (AWidth=FWidth) and (AHeight=FHeight) then Exit;
  FreeBuffer;
  FWidth:=AWidth;
  FHeight:=AHeight;
  if FWidth <= 0 then FWidth:=1;
  if FHeight <= 0 then FHeight:=1;
  FResized:=true;
  if FBuffered then
  begin

    with FBitmapInfo.bmiHeader do
    begin
      biSize:=SizeOf(TBitmapInfoHeader);
      biPlanes:=1;
      biBitCount:=32;
      biCompression:=BI_RGB;
      biWidth:=AWidth;
      if biWidth <= 0 then biWidth:=1;
      biHeight:=-AHeight;
      if biHeight >= 0 then biHeight:=-1;
    end;

    FBufferHandle:=CreateDIBSection(0,FBitmapInfo,DIB_RGB_COLORS,Pointer(FBufferBits),0,0);
    if FBufferBits=nil then
      raise Exception.Create('Can''t allocate the DIB handle');

    FHandle:=CreateCompatibleDC(0);
    if FHandle=0 then
    begin
      DeleteObject(FBufferHandle);
      FHandle:=0;
      FBufferBits:=nil;
      raise Exception.Create('Can''t create compatible DC');
    end;

    if SelectObject(FHandle,FBufferHandle)=0 then
    begin
      DeleteDC(FHandle);
      DeleteObject(FBufferHandle);
      FHandle:=0;
      FBufferHandle:=0;
      FBufferBits:=nil;
      raise Exception.Create('Can''t select an object into DC');
    end;
  end;
  FGraphics:=TGPGraphics.Create(FHandle);
  FGraphics.SetSmoothingMode(QualityModeHigh);
  FGraphics.SetInterpolationMode(InterpolationModeHighQuality);
  FGraphics.SetPixelOffsetMode(PixelOffsetModeHalf);
  FGraphics.SetCompositingMode(CompositingModeSourceOver);
  FGraphics.SetTextContrast(2);
  FFontScale:=96 / FGraphics.GetDpiX;
end;

procedure TD2CanvasGdiPlus.FlushBuffer(const X,Y:integer; const DC:Cardinal);
begin
  if FBufferHandle=0 then Exit;
  if DC=0 then Exit;
  Windows.BitBlt(DC,X,Y,FWidth,FHeight,FHandle,0,0,SRCCOPY);
end;

procedure TD2CanvasGdiPlus.FlushBufferRect(const X,Y:integer; const DC:Cardinal;
  const ARect:TD2Rect);
var
  R:TRect;
begin
  if FBufferHandle=0 then Exit;
  if DC=0 then Exit;
  R:=Rect(trunc(ARect.left),trunc(ARect.top),trunc(ARect.right) + 1,trunc(ARect.bottom) + 1);
  with R do
  begin
    Windows.BitBlt(DC,X + R.left,Y + R.top,R.right - R.left,R.bottom - R.top,FHandle,R.left,R.top,SRCCOPY);
  end;
end;

procedure TD2CanvasGdiPlus.Clear(const Color:cardinal);
begin
  if not (FBuffered or (FBitmap <> nil)) then Exit;
  FGraphics.Clear(Color)
end;

procedure TD2CanvasGdiPlus.ClearRect(const ARect:TD2Rect; const AColor:TD2Color);
var
  R:TRect;
begin
  if not (FBuffered or (FBitmap <> nil)) then Exit;
  R:=Rect(Trunc(ARect.Left),Trunc(ARect.Top),Round(ARect.Right),Round(ARect.Bottom));
  if R.Left < 0 then R.Left:=0;
  if R.Top < 0 then R.Top:=0;
  if R.Top < 0 then R.Top:=0;
  if R.Right > FWidth then R.Right:=FWidth;
  if R.Bottom > FHeight then R.Bottom:=FHeight;
  if R.Bottom < R.Top then R.Bottom:=R.Top;
  if R.Right < R.Left then R.Right:=R.Left;
  if (R.Right < 0) or (R.Top < 0) or (R.Left > FWidth) or (R.Top > FHeight) then Exit;
  d2FillLongwordRect(FBufferBits,FWidth,FHeight,R.Left,R.Top,R.Right,R.Bottom,AColor);
end;

class function TD2CanvasGdiPlus.GetBitmapScanline(Bitmap:TD2Bitmap; y:integer):PD2ColorArray;
begin
  if (y >= 0) and (y < Bitmap.Height) and (Bitmap.StartLine <> nil) then
    Result:=@PD2ColorArray(Bitmap.StartLine)[(y) * Bitmap.Width]
  else
    Result:=nil;
end;

procedure TD2CanvasGdiPlus.SetMatrix(const M:TD2Matrix);
var
  GM:TGPMatrix;
begin
  FMatrix:=M;
  with FMatrix do
  begin
    GM:=TGPMatrix.Create(m11,m12,m21,m22,m31,m32);
    GM.Shear(m13,m23);
  end;
  FGraphics.SetTransform(GM);
  GM.Free;
end;

procedure TD2CanvasGdiPlus.MultyMatrix(const M:TD2Matrix);
var
  GM:TGPMatrix;
begin
  inherited;
  with M do
  begin
    GM:=TGPMatrix.Create(m11,m12,m21,m22,m31,m32);
    GM.Shear(m13,m23);
  end;
  FGraphics.MultiplyTransform(GM);
  GM.Free;
end;

function TD2CanvasGdiPlus.SaveCanvas:cardinal;
var
  i:integer;
begin
  Result:=InvalideCanvasState;
  if FGraphics=nil then Exit;

  if Length(FSaveData) > 0 then
    for i:=0 to High(FSaveData) do
      if FSaveData[i].Index=InvalideCanvasState then
      begin
        Result:=i;
        Break;
      end;
  if Result=InvalideCanvasState then
  begin
    SetLength(FSaveData,Length(FSaveData) + 1);
    Result:=High(FSaveData);
  end;
  FSaveData[Result].Index:=FGraphics.Save;
  FSaveData[Result].Matrix:=FMatrix;
  FSaveData[Result].Stroke:=TD2Brush.Create(d2BrushSolid,InvalideCanvasState);
  FSaveData[Result].Stroke.Assign(Stroke);
  FSaveData[Result].Fill:=TD2Brush.Create(d2BrushSolid,$FF000000);
  FSaveData[Result].Fill.Assign(Fill);
  FSaveData[Result].StrokeThickness:=FStrokeThickness;
  FSaveData[Result].StrokeCap:=StrokeCap;
  FSaveData[Result].StrokeJoin:=StrokeJoin;
  FSaveData[Result].StrokeDash:=StrokeDash;
  if StrokeDash <> d2DashSolid then
  begin
    SetLength(FSaveData[Result].Dash,Length(FDash));
    Move(FDash[0],FSaveData[Result].Dash[0],SizeOf(FDash[0]) * Length(FDash));
  end;
  FSaveData[Result].DashOffset:=FDashOffset;
  FSaveData[Result].Font:=TD2Font.Create;
  FSaveData[Result].Font.Assign(Font);
end;

procedure TD2CanvasGdiPlus.RestoreCanvas(const AState:cardinal);
begin
  if FGraphics=nil then Exit;

  if (AState >= 0) and (AState < Length(FSaveData)) then
  begin
    FGraphics.Restore(FSaveData[AState].Index);

    FSaveData[AState].Index:=InvalideCanvasState;

    FMatrix:=FSaveData[AState].Matrix;
    Stroke.Assign(FSaveData[AState].Stroke);
    FSaveData[AState].Stroke.Free;
    Fill.Assign(FSaveData[AState].Fill);
    FSaveData[AState].Fill.Free;
    SetMatrix(FMatrix);
    FStrokeThickness:=FSaveData[AState].StrokeThickness;
    FStrokeCap:=FSaveData[AState].StrokeCap;
    FStrokeJoin:=FSaveData[AState].StrokeJoin;
    FStrokeDash:=FSaveData[AState].StrokeDash;
    if StrokeDash <> d2DashSolid then
    begin
      SetLength(FDash,Length(FSaveData[AState].Dash));
      Move(FSaveData[AState].Dash[0],FDash[0],SizeOf(FDash[0]) * Length(FDash));
    end;
    FDashOffset:=FSaveData[AState].DashOffset;
    Font.Assign(FSaveData[AState].Font);
    FSaveData[AState].Font.Free;
  end
end;

procedure TD2CanvasGdiPlus.SetClipRects(const ARects:array of TD2Rect);
var
  i:integer;
  R:TGPRegion;
  //GM:TGPMatrix;
begin
  R:=TGPRegion.Create;
  R.MakeEmpty;
  for i:=0 to High(ARects) do
  begin
    R.Union(GPRectFromRect(ARects[i]));
  end;
  FGraphics.SetClip(R);
  R.Free;
end;

procedure TD2CanvasGdiPlus.IntersectClipRect(const ARect:TD2Rect);
begin
  FGraphics.IntersectClip(MakeRect(ARect.Left,ARect.Top,ARect.Right - ARect.Left,ARect.Bottom - ARect.Top));
end;

procedure TD2CanvasGdiPlus.ExcludeClipRect(const ARect:TD2Rect);
begin
  FGraphics.ExcludeClip(GPRectFromRect(ARect));
end;

procedure TD2CanvasGdiPlus.ResetClipRect;
begin
  FGraphics.ResetClip;
end;

procedure TD2CanvasGdiPlus.ApplyFill(ARect:TD2Rect; const AOpacity:single);
var
  //C:TD2Color;
  i:integer;
  count:integer;
  B:TD2Bitmap;
  P:TGPGraphicsPath;
  M:TGPMatrix;
  CM:TColorMatrix;
  ImageAttributes:TGPImageAttributes;
begin
  if FGPBrush <> nil then FreeAndNil(FGPBrush);
  if (FFill.Style=d2BrushResource) and (FFill.Resource <> nil) and (FFill.Resource.Brush <> nil) then
    FFill.Assign(FFill.Resource.Brush);

  with FFill do
  begin
    case Style of
      d2BrushSolid:
        begin
          FGPBrush:=TGPSolidBrush.Create(d2Opacity(SolidColor,AOpacity));
        end;
      d2BrushGradient:
        begin
          if Gradient.Points.Count > 1 then
          begin
            count:=0;

            if Gradient.Points[0].Offset > 0 then
            begin
              ColorArray[count]:=d2Opacity(Gradient.Points[0].IntColor,AOpacity);
              OffsetArray[count]:=0;
              count:=count + 1;
            end;
            for i:=0 to Gradient.Points.Count - 1 do
            begin
              ColorArray[i + count]:=d2Opacity(Gradient.Points[i].IntColor,AOpacity);
              OffsetArray[i + count]:=Gradient.Points[i].Offset;
            end;
            if Gradient.Points[Gradient.Points.Count - 1].Offset < 1 then
            begin
              count:=count + 1;
              ColorArray[Gradient.Points.Count + count - 1]:=d2Opacity(Gradient.Points[Gradient.Points.Count - 1].IntColor,AOpacity);
              OffsetArray[Gradient.Points.Count + count - 1]:=1;
            end;

            if Gradient.Style=d2LinearGradient then
            begin

              FGPBrush:=TGPLinearGradientBrush.Create(MakePoint(ARect.Left + Gradient.StartPosition.X * ARect.Right,ARect.Top + Gradient.StartPosition.Y * ARect.Bottom),
                MakePoint(ARect.Left + Gradient.StopPosition.X * ARect.Right,ARect.Top + Gradient.StopPosition.Y * ARect.Bottom),SolidColor,SolidColor);
              TGPLinearGradientBrush(FGPBrush).SetWrapMode(WrapModeTileFlipX);
              TGPLinearGradientBrush(FGPBrush).SetInterpolationColors(PGPColor(@ColorArray),PSingle(@OffsetArray),Gradient.Points.Count + count);
            end
            else
            begin

              P:=TGPGraphicsPath.Create;
              P.AddEllipse(GPRectFromRect(ARect));
              FGPBrush:=TGPPathGradientBrush.Create(P);
              P.Free;
              with Gradient.RadialTransform do
                M:=TGPMatrix.Create(Matrix.m11,Matrix.m12,Matrix.m21,Matrix.m22,Matrix.m31,Matrix.m32);
              TGPPathGradientBrush(FGPBrush).SetTransform(M);
              M.Free;
              TGPPathGradientBrush(FGPBrush).SetWrapMode(WrapModeClamp);
              TGPPathGradientBrush(FGPBrush).SetInterpolationColors(PARGB(@ColorArray),PSingle(@OffsetArray),Gradient.Points.Count + count);
            end;
          end
          else
            FGPBrush:=TGPSolidBrush.Create(d2Opacity(SolidColor,AOpacity));
        end;
      d2BrushResource:
        begin
          FGPBrush:=TGPSolidBrush.Create($00000000);
        end;
      d2BrushVisual:
        begin
          FGPBrush:=TGPSolidBrush.Create($00000000);
        end;
      d2BrushBitmap:
        begin
          B:=Bitmap.Bitmap;
          if (B <> nil) and (B.ResourceBitmap <> nil) then
            B:=B.ResourceBitmap;
          if (B <> nil) and (B.Width > 0) and (B.Height > 0) then
          begin
            UpdateBitmap(B);
            if (B.Handle <> 0) then
            begin
              CM:=imgColorMatrix;
              CM[3][3]:=AOpacity;
              if Aopacity <> 1 then
              begin
                ImageAttributes:=TGPImageAttributes.Create;
                ImageAttributes.SetColorMatrix(CM,ColorMatrixFlagsDefault,ColorAdjustTypeBitmap);
              end
              else
                ImageAttributes:=nil;
              if Bitmap.WrapMode <> d2WrapTileStretch then
              begin
                FGPBrush:=TGPTextureBrush.Create(TGPBitmap(B.Handle),
                  GPRectFromRect(d2Rect(0,0,B.Width,B.Height)),ImageAttributes);
                TGPTextureBrush(FGPBrush).SetWrapMode(TWrapMode(Bitmap.WrapMode));
              end
              else
              begin
                FGPBrush:=TGPTextureBrush.Create(TGPBitmap(B.Handle),
                  GPRectFromRect(d2Rect(0,0,B.Width,B.Height)),ImageAttributes);
                TGPTextureBrush(FGPBrush).SetWrapMode(WrapModeClamp);
                TGPTextureBrush(FGPBrush).ScaleTransform((d2RectWidth(ARect) + (StrokeThickness / 2)) / B.Width,
                  (d2RectHeight(ARect) + (StrokeThickness / 2)) / B.Height);
              end;
              if Aopacity <> 1 then
                ImageAttributes.Free;
            end
            else
              FGPBrush:=TGPSolidBrush.Create($00000000);
          end
          else
            FGPBrush:=TGPSolidBrush.Create($00000000);
        end;
    else
      FGPBrush:=TGPSolidBrush.Create($00000000);
    end;
  end;
end;

procedure TD2CanvasGdiPlus.ApplyStroke(ARect:TD2Rect; const AOpacity:single);
var
  i:integer;
begin
  if FGPPen <> nil then FreeAndNil(FGPPen);
  if FGPPenBrush <> nil then FreeAndNil(FGPPenBrush);
  if (FStroke.Style=d2BrushResource) and (FStroke.Resource <> nil) and (FStroke.Resource.Brush <> nil) then
    FStroke.Assign(FStroke.Resource.Brush);

  with FStroke do
  begin
    case Style of
      d2BrushSolid:
        begin
          FGPPenBrush:=TGPSolidBrush.Create(d2Opacity(SolidColor,AOpacity));
        end;
      d2BrushGradient:
        begin
          if Gradient.Points.Count > 1 then
          begin
            for i:=0 to Gradient.Points.Count - 1 do
            begin
              ColorArray[i]:=d2Opacity(Gradient.Points[i].IntColor,AOpacity);
              OffsetArray[i]:=Gradient.Points[i].Offset;
            end;
            FGPPenBrush:=TGPLinearGradientBrush.Create(MakePoint(ARect.Left + Gradient.StartPosition.X * ARect.Right,ARect.Top + Gradient.StartPosition.Y * ARect.Bottom),
              MakePoint(ARect.Left + Gradient.StopPosition.X * ARect.Right,ARect.Top + Gradient.StopPosition.Y * ARect.Bottom),SolidColor,SolidColor);
            TGPLinearGradientBrush(FGPPenBrush).SetInterpolationColors(PGPColor(@ColorArray),PSingle(@OffsetArray),Gradient.Points.Count);
            if Abs(FStroke.Gradient.StartPosition.X - FStroke.Gradient.StopPosition.X) < Abs(FStroke.Gradient.StartPosition.Y - FStroke.Gradient.StopPosition.Y) then
              TGPLinearGradientBrush(FGPPenBrush).ScaleTransform(d2RectHeight(ARect),d2RectWidth(ARect))
            else
              TGPLinearGradientBrush(FGPPenBrush).ScaleTransform(d2RectWidth(ARect),d2RectHeight(ARect));
          end
          else
            FGPPenBrush:=TGPSolidBrush.Create(d2Opacity(SolidColor,AOpacity));
        end;
      d2BrushVisual:
        begin
          FGPPenBrush:=TGPSolidBrush.Create($00000000);
        end;
      d2BrushBitmap:
        begin
          if (Bitmap.Bitmap <> nil) and (Bitmap.Bitmap.Width > 0) and (Bitmap.Bitmap.Height > 0) then
          begin
            UpdateBitmap(Bitmap.Bitmap);
            if (Bitmap.Bitmap.Handle <> 0) then
            begin
              if Bitmap.WrapMode <> d2WrapTileStretch then
                FGPPenBrush:=TGPTextureBrush.Create(TGPBitmap(Bitmap.Bitmap.Handle),TWrapMode(Bitmap.WrapMode))
              else
              begin
                FGPPenBrush:=TGPTextureBrush.Create(TGPBitmap(Bitmap.Bitmap.Handle),WrapModeClamp);
                TGPTextureBrush(FGPPenBrush).ScaleTransform(d2RectWidth(ARect) / Bitmap.Bitmap.Width,d2RectHeight(ARect) / Bitmap.Bitmap.Height);
              end;
            end
            else
              FGPPenBrush:=TGPSolidBrush.Create($00000000);
          end
          else
            FGPPenBrush:=TGPSolidBrush.Create($00000000);
        end;
    else
      FGPPenBrush:=TGPSolidBrush.Create($00000000);
    end;
  end;

  FGPPen:=TGPPen.Create(FGPPenBrush);
  case StrokeCap of
    d2CapFlat:FGPPen.SetLineCap(LineCapFlat,LineCapFlat,LineCapFlat);
    d2CapRound:FGPPen.SetLineCap(LineCapRound,LineCapRound,LineCapRound);
  end;
  if Length(FDash) > 0 then
  begin
    FGPPen.SetDashOffset(FDashOffset);
    FGPPen.SetDashPattern(@FDash[0],Length(FDash));
  end
  else
    FGPPen.SetDashStyle(DashStyleSolid);
  case StrokeJoin of
    d2JoinMiter:FGPPen.SetLineJoin(LineJoinMiter);
    d2JoinRound:FGPPen.SetLineJoin(LineJoinRound);
    d2JoinBevel:FGPPen.SetLineJoin(LineJoinBevel);
  end;
  FGPPen.SetWidth(StrokeThickness);
end;

procedure TD2CanvasGdiPlus.FontChanged(Sender:TObject);
begin
  FreeAndNil(FGPFamily);
  FGPFamily:=TGPFontFamily.Create(FFont.Family,FFontCollection);
  if not FGPFamily.IsAvailable then
  begin
    FGPFamily.Free;
    FGPFamily:=TGPFontFamily.Create(FFont.Family);
    if not FGPFamily.IsAvailable then
    begin
      FGPFamily.Free;
      FGPFamily:=TGPFontFamily.GenericSansSerif.Clone;
    end
  end;
  if FGraphics <> nil then
  begin
    if FFont.ClearType then
      FGraphics.SetTextRenderingHint(TextRenderingHintClearTypeGridFit)
    else
      FGraphics.SetTextRenderingHint(TextRenderingHintAntiAlias);
  end;
end;

procedure TD2CanvasGdiPlus.DrawLine(const APt1,APt2:TD2Point; const AOpacity:single);
begin
  if FStroke.Style <> d2BrushNone then
  begin
    ApplyStroke(d2Rect(APt1.X,APt1.Y,APt2.X,APt2.Y),AOpacity);
    FGraphics.DrawLine(FGPPen,APt1.X,APt1.Y,APt2.X,APt2.Y);
  end;
end;

procedure TD2CanvasGdiPlus.IntFillRect(R:TD2Rect;
  Opacity:single);
var
  Save:cardinal;
  //GPR:TGPRectF;
  Visual:TD2VisualObject;
  //M:TD2Matrix;
  SaveOpacity:single;
  SaveStroke:TD2Brush;
  SaveStrokeThickness:single;
begin
  if FFill.Style <> d2BrushNone then
  begin
    if FFill.Style=d2BrushVisual then
    begin
      Save:=SaveCanvas;
      FGraphics.IntersectClip(GPRectFromRect(R));
      if FFill.Visual.VisualObject <> nil then
      begin
        Visual:=FFill.Visual.VisualObject;
        SaveOpacity:=Visual.Opacity;
        SaveStroke:=TD2Brush.Create(d2BrushSolid,$FF000000);
        SaveStroke.Assign(Stroke);
        SaveStrokeThickness:=StrokeThickness;
        Visual.Opacity:=Opacity;

        Visual.PaintTo(Self,R);

        Visual.Opacity:=SaveOpacity;
        Stroke.Assign(SaveStroke);
        SaveStroke.Free;
        StrokeThickness:=SaveStrokeThickness;
      end;
      RestoreCanvas(Save);
    end
    else
    begin
      ApplyFill(R,Opacity);
      FGraphics.FillRectangle(FGPBrush,GPRectFromRect(R));
    end;
  end;
end;

procedure TD2CanvasGdiPlus.IntFillPath(P:TGPGraphicsPath; R:TD2Rect;
  Opacity:single);
var
  Save:cardinal;
  Rg:TGPRegion;
  Visual:TD2VisualObject;
  //M:TD2Matrix;
  SaveOpacity:single;
  SaveStroke:TD2Brush;
  SaveStrokeThickness:single;
begin
  if FFill.Style <> d2BrushNone then
  begin
    if FFill.Style=d2BrushVisual then
    begin
      Save:=SaveCanvas;
      Rg:=TGPRegion.Create(P);
      FGraphics.IntersectClip(Rg);
      Rg.Free;
      if FFill.Visual.VisualObject <> nil then
      begin
        Visual:=FFill.Visual.VisualObject;
        SaveOpacity:=Visual.Opacity;
        SaveStroke:=TD2Brush.Create(d2BrushSolid,$FF000000);
        SaveStroke.Assign(Stroke);
        SaveStrokeThickness:=StrokeThickness;
        Visual.Opacity:=Opacity;

        Visual.PaintTo(Self,R);

        Visual.Opacity:=SaveOpacity;
        Stroke.Assign(SaveStroke);
        SaveStroke.Free;
        StrokeThickness:=SaveStrokeThickness;
      end;
      RestoreCanvas(Save);
    end
    else
    begin
      ApplyFill(R,Opacity);
      FGraphics.FillPath(FGPBrush,P);
    end;
  end;
end;

procedure TD2CanvasGdiPlus.DrawRect(const ARect:TD2Rect; const xRadius,yRadius:single; const ACorners:TD2Corners;
  const AOpacity:single; const ACornerType:TD2CornerType=d2CornerRound);
var
  Path:TGPGraphicsPath;
  x1,x2,y1,y2:single;
  R:TD2Rect;
begin
  if FStroke.Style <> d2BrushNone then
  begin
    R:=ARect;
    ApplyStroke(R,AOpacity);
    if (xRadius < Epsilon) and (yRadius < Epsilon) then
    begin
      FGraphics.DrawRectangle(FGPPen,GPRectFromRect(R));
    end
    else
    begin
      x1:=xRadius;
      if d2RectWidth(R) - (x1 * 2) < 0 then
        x1:=(xRadius * (d2RectWidth(R) / (x1 * 2)));
      x2:=x1 * CurveKappaInv;
      y1:=yRadius;
      if d2RectHeight(R) - (y1 * 2) < 0 then
        y1:=(yRadius * (d2RectHeight(R) / (y1 * 2)));
      y2:=y1 * CurveKappaInv;
      Path:=TGPGraphicsPath.Create;
      if d2CornerTopLeft in ACorners then
      begin
        case ACornerType of
          d2CornerBevel:Path.AddLine(R.Left,R.Top + y1,R.Left + x1,R.Top);
          d2CornerInnerRound:Path.AddBezier(R.Left,R.Top + y1,R.Left + x2,R.Top + y1,R.Left + x1,R.Top + y2,R.Left + x1,R.Top);
          d2CornerInnerLine:
            begin
              Path.AddLine(R.Left,R.Top + y1,R.Left + x2,R.Top + y1);
              Path.AddLine(R.Left + x2,R.Top + y1,R.Left + x1,R.Top + y2);
              Path.AddLine(R.Left + x1,R.Top + y2,R.Left + x1,R.Top);
            end;
        else
          Path.AddBezier(R.Left,R.Top + y1,R.Left,R.Top + (y2),R.Left + x2,R.Top,R.Left + x1,R.Top)
        end;
      end
      else
      begin
        Path.AddLine(R.Left,R.Top + y1,R.Left,R.Top);
        Path.AddLine(R.Left,R.Top,R.Left + x1,R.Top);
      end;
      if d2CornerTopRight in ACorners then
      begin
        case ACornerType of
          d2CornerBevel:Path.AddLine(R.Right - x1,R.Top,R.Right,R.Top + y1);
          d2CornerInnerRound:Path.AddBezier(R.Right - x1,R.Top,R.Right - x1,R.Top + y2,R.Right - x2,R.Top + y1,R.Right,R.Top + y1);
          d2CornerInnerLine:
            begin
              Path.AddLine(R.Right - x1,R.Top,R.Right - x1,R.Top + y2);
              Path.AddLine(R.Right - x1,R.Top + y2,R.Right - x2,R.Top + y1);
              Path.AddLine(R.Right - x2,R.Top + y1,R.Right,R.Top + y1);
            end;
        else
          Path.AddBezier(R.Right - x1,R.Top,R.Right - x2,R.Top,R.Right,R.Top + (y2),R.Right,R.Top + y1)
        end;
      end
      else
      begin
        Path.AddLine(R.Right - x1,R.Top,R.Right,R.Top);
        Path.AddLine(R.Right,R.Top,R.Right,R.Top + y1);
      end;
      if d2CornerBottomRight in ACorners then
      begin
        case ACornerType of
          d2CornerBevel:Path.AddLine(R.Right,R.Bottom - y1,R.Right - x1,R.Bottom);
          d2CornerInnerRound:Path.AddBezier(R.Right,R.Bottom - y1,R.Right - x2,R.Bottom - y1,R.Right - x1,R.Bottom - y2,R.Right - x1,R.Bottom);
          d2CornerInnerLine:
            begin
              Path.AddLine(R.Right,R.Bottom - y1,R.Right - x2,R.Bottom - y1);
              Path.AddLine(R.Right - x2,R.Bottom - y1,R.Right - x1,R.Bottom - y2);
              Path.AddLine(R.Right - x1,R.Bottom - y2,R.Right - x1,R.Bottom);
            end;
        else
          Path.AddBezier(R.Right,R.Bottom - y1,R.Right,R.Bottom - (y2),R.Right - x2,R.Bottom,R.Right - x1,R.Bottom)
        end;
      end
      else
      begin
        Path.AddLine(R.Right,R.Bottom - y1,R.Right,R.Bottom);
        Path.AddLine(R.Right,R.Bottom,R.Right - x1,R.Bottom);
      end;
      if d2CornerBottomLeft in ACorners then
      begin
        case ACornerType of
          d2CornerBevel:Path.AddLine(R.Left + x1,R.Bottom,R.Left,R.Bottom - y1);
          d2CornerInnerRound:Path.AddBezier(R.Left + x1,R.Bottom,R.Left + x1,R.Bottom - y2,R.Left + x2,R.Bottom - y1,R.Left,R.Bottom - y1);
          d2CornerInnerLine:
            begin
              Path.AddLine(R.Left + x1,R.Bottom,R.Left + x1,R.Bottom - y2);
              Path.AddLine(R.Left + x1,R.Bottom - y2,R.Left + x2,R.Bottom - y1);
              Path.AddLine(R.Left + x2,R.Bottom - y1,R.Left,R.Bottom - y1);
            end;
        else
          Path.AddBezier(R.Left + x1,R.Bottom,R.Left + x2,R.Bottom,R.Left,R.Bottom - (y2),R.Left,R.Bottom - y1)
        end;
      end
      else
      begin
        Path.AddLine(R.Left + x1,R.Bottom,R.Left,R.Bottom);
        Path.AddLine(R.Left,R.Bottom,R.Left,R.Bottom - y1);
      end;
      {$IFDEF FLATTEN}
      Path.Flatten();
      {$ENDIF}
      Path.CloseFigure;
      FGraphics.DrawPath(FGPPen,Path);
      Path.Free;
    end;
  end;
end;

procedure TD2CanvasGdiPlus.FillRect(const ARect:TD2Rect; const xRadius,yRadius:single; const ACorners:TD2Corners; const AOpacity:single;
  const ACornerType:TD2CornerType=d2CornerRound);
var
  Path:TGPGraphicsPath;
  x1,x2,y1,y2:single;
  R:TD2Rect;
begin
  if FFill.Style <> d2BrushNone then
  begin
    R:=ARect;
    if ((xRadius=0) and (yRadius=0)) or (ACorners=[]) then
    begin
      IntFillRect(R,AOpacity);
    end
    else
    begin
      x1:=xRadius;
      if d2RectWidth(R) - (x1 * 2) < 0 then
        x1:=(xRadius * (d2RectWidth(R) / (x1 * 2)));
      x2:=x1 * CurveKappaInv;
      y1:=yRadius;
      if d2RectHeight(R) - (y1 * 2) < 0 then
        y1:=(yRadius * (d2RectHeight(R) / (y1 * 2)));
      y2:=y1 * CurveKappaInv;
      Path:=TGPGraphicsPath.Create;
      if d2CornerTopLeft in ACorners then
      begin
        case ACornerType of
          d2CornerBevel:Path.AddLine(R.Left,R.Top + y1,R.Left + x1,R.Top);
          d2CornerInnerRound:Path.AddBezier(R.Left,R.Top + y1,R.Left + x2,R.Top + y1,R.Left + x1,R.Top + y2,R.Left + x1,R.Top);
          d2CornerInnerLine:
            begin
              Path.AddLine(R.Left,R.Top + y1,R.Left + x2,R.Top + y1);
              Path.AddLine(R.Left + x2,R.Top + y1,R.Left + x1,R.Top + y2);
              Path.AddLine(R.Left + x1,R.Top + y2,R.Left + x1,R.Top);
            end;
        else
          Path.AddBezier(R.Left,R.Top + y1,R.Left,R.Top + (y2),R.Left + x2,R.Top,R.Left + x1,R.Top)
        end;
      end
      else
      begin
        Path.AddLine(R.Left,R.Top + y1,R.Left,R.Top);
        Path.AddLine(R.Left,R.Top,R.Left + x1,R.Top);
      end;
      if d2CornerTopRight in ACorners then
      begin
        case ACornerType of
          d2CornerBevel:Path.AddLine(R.Right - x1,R.Top,R.Right,R.Top + y1);
          d2CornerInnerRound:Path.AddBezier(R.Right - x1,R.Top,R.Right - x1,R.Top + y2,R.Right - x2,R.Top + y1,R.Right,R.Top + y1);
          d2CornerInnerLine:
            begin
              Path.AddLine(R.Right - x1,R.Top,R.Right - x1,R.Top + y2);
              Path.AddLine(R.Right - x1,R.Top + y2,R.Right - x2,R.Top + y1);
              Path.AddLine(R.Right - x2,R.Top + y1,R.Right,R.Top + y1);
            end;
        else
          Path.AddBezier(R.Right - x1,R.Top,R.Right - x2,R.Top,R.Right,R.Top + (y2),R.Right,R.Top + y1)
        end;
      end
      else
      begin
        Path.AddLine(R.Right - x1,R.Top,R.Right,R.Top);
        Path.AddLine(R.Right,R.Top,R.Right,R.Top + y1);
      end;
      if d2CornerBottomRight in ACorners then
      begin
        case ACornerType of
          d2CornerBevel:Path.AddLine(R.Right,R.Bottom - y1,R.Right - x1,R.Bottom);
          d2CornerInnerRound:Path.AddBezier(R.Right,R.Bottom - y1,R.Right - x2,R.Bottom - y1,R.Right - x1,R.Bottom - y2,R.Right - x1,R.Bottom);
          d2CornerInnerLine:
            begin
              Path.AddLine(R.Right,R.Bottom - y1,R.Right - x2,R.Bottom - y1);
              Path.AddLine(R.Right - x2,R.Bottom - y1,R.Right - x1,R.Bottom - y2);
              Path.AddLine(R.Right - x1,R.Bottom - y2,R.Right - x1,R.Bottom);
            end;
        else
          Path.AddBezier(R.Right,R.Bottom - y1,R.Right,R.Bottom - (y2),R.Right - x2,R.Bottom,R.Right - x1,R.Bottom)
        end;
      end
      else
      begin
        Path.AddLine(R.Right,R.Bottom - y1,R.Right,R.Bottom);
        Path.AddLine(R.Right,R.Bottom,R.Right - x1,R.Bottom);
      end;
      if d2CornerBottomLeft in ACorners then
      begin
        case ACornerType of
          d2CornerBevel:Path.AddLine(R.Left + x1,R.Bottom,R.Left,R.Bottom - y1);
          d2CornerInnerRound:Path.AddBezier(R.Left + x1,R.Bottom,R.Left + x1,R.Bottom - y2,R.Left + x2,R.Bottom - y1,R.Left,R.Bottom - y1);
          d2CornerInnerLine:
            begin
              Path.AddLine(R.Left + x1,R.Bottom,R.Left + x1,R.Bottom - y2);
              Path.AddLine(R.Left + x1,R.Bottom - y2,R.Left + x2,R.Bottom - y1);
              Path.AddLine(R.Left + x2,R.Bottom - y1,R.Left,R.Bottom - y1);
            end;
        else
          Path.AddBezier(R.Left + x1,R.Bottom,R.Left + x2,R.Bottom,R.Left,R.Bottom - (y2),R.Left,R.Bottom - y1)
        end;
      end
      else
      begin
        Path.AddLine(R.Left + x1,R.Bottom,R.Left,R.Bottom);
        Path.AddLine(R.Left,R.Bottom,R.Left,R.Bottom - y1);
      end;
      {$IFDEF FLATTEN}
      Path.Flatten();
      {$ENDIF}
      Path.CloseFigure;
      IntFillPath(Path,ARect,AOpacity);
      Path.Free;
    end;
  end;
end;

procedure TD2CanvasGdiPlus.DrawEllipse(const ARect:TD2Rect; const AOpacity:single);
var
  R:TD2Rect;
  //P:TGPGraphicsPath;
begin
  if FStroke.Style <> d2BrushNone then
  begin
    ApplyStroke(ARect,AOpacity);
    R:=d2Rect(ARect.left,ARect.Top,ARect.Right,ARect.Bottom);
    FGraphics.DrawEllipse(FGPPen,GPRectFromRect(R));
  end;
end;

procedure TD2CanvasGdiPlus.FillEllipse(const ARect:TD2Rect; const AOpacity:single);
var
  R:TD2Rect;
  P:TGPGraphicsPath;
begin
  if FFill.Style <> d2BrushNone then
  begin
    P:=TGPGraphicsPath.Create();
    R:=d2Rect(ARect.left,ARect.Top,ARect.Right - ARect.Left,ARect.Bottom - ARect.Top);
    P.AddEllipse(R.Left,R.Top,R.Right,R.Bottom);
    IntFillPath(P,R,AOpacity);
    P.Free;
  end;
end;

function TD2CanvasGdiPlus.LoadFontFromStream(AStream:TStream):boolean;
var
  Stream:TMemoryStream;
begin
  if FFontCollection=nil then
    FFontCollection:=TGPPrivateFontCollection.Create;
  Stream:=TMemoryStream.Create;
  Stream.CopyFrom(AStream,AStream.Size);
  FFontCollection.AddMemoryFont(Stream.Memory,Stream.Size);
  Stream.Free;
end;

procedure TD2CanvasGdiPlus.FillText(const ARect,AClipRect:TD2Rect; const AText:WideString; const WordWrap:boolean;
  const AOpacity:single; const ATextAlign:TD2TextAlign; const AVTextAlign:TD2TextAlign=d2TextAlignCenter);
var
  StringFormat:TGPStringFormat;
  Font:TGPFont;
  S:TD2FontStyle;
begin
  if (FFill.Style <> d2BrushNone) and (AText <> '') then
  begin
    StringFormat:=TGPStringFormat.Create(StringFormatFlagsNoClip);
    if not WordWrap then
      StringFormat.SetFormatFlags(StringFormat.GetFormatFlags or StringFormatFlagsNoWrap);
    if not FGPFamily.IsStyleAvailable(d2StyleToGPStyle(FFont.Style)) then
    begin
      Font:=nil;
      for S:=d2FontRegular to d2FontStrikeout do
      begin
        if FGPFamily.IsStyleAvailable(d2StyleToGPStyle(S)) then
        begin
          Font:=TGPFont.Create(FGPFamily,(FFont.Size * 0.75 * FFontScale),d2StyleToGPStyle(S));
          Break;
        end;
      end;
      if Font=nil then
        Font:=TGPFont.Create(FGPFamily,(FFont.Size * 0.75 * FFontScale),d2StyleToGPStyle(FFont.Style));
    end
    else
      Font:=TGPFont.Create(FGPFamily,(FFont.Size * 0.75 * FFontScale),d2StyleToGPStyle(FFont.Style),UnitPoint);

    case ATextAlign of
      d2TextAlignCenter:  stringFormat.SetAlignment(StringAlignmentCenter);
      d2TextAlignNear:    stringFormat.SetAlignment(StringAlignmentNear);
      d2TextAlignFar:     stringFormat.SetAlignment(StringAlignmentFar);
    end;

    case AVTextAlign of
      d2TextAlignCenter: stringFormat.SetLineAlignment(StringAlignmentCenter);
      d2TextAlignNear:   stringFormat.SetLineAlignment(StringAlignmentNear);
      d2TextAlignFar:    stringFormat.SetLineAlignment(StringAlignmentFar);
    end;

    if AOpacity=1 then
      ApplyFill(ARect,AOpacity * 0.99) else
      ApplyFill(ARect,AOpacity);

    if (frac(FMatrix.m11) <> 0) or (frac(FMatrix.m22) <> 0) then
    begin
      FGraphics.SetTextRenderingHint(TextRenderingHintAntiAlias);
      FGraphics.DrawString(AText,-1,Font,GPRectFromRect(ARect),StringFormat,FGPBrush);
      if FFont.ClearType then
        FGraphics.SetTextRenderingHint(TextRenderingHintClearTypeGridFit) else
        FGraphics.SetTextRenderingHint(TextRenderingHintAntiAlias);
    end else
    begin
      FGraphics.DrawString(AText,-1,Font,GPRectFromRect(ARect),StringFormat,FGPBrush);
    end;
      
    Font.Free;
    StringFormat.Free;
  end;
end;

procedure TD2CanvasGdiPlus.MeasureText(var ARect:TD2Rect;
  AClipRect:TD2Rect; const AText:WideString; const WordWrap:boolean;
  const ATextAlign,AVTextAlign:TD2TextAlign);
var
  StringFormat:TGPStringFormat;
  Font:TGPFont;
  GR:TGPRectF;
  charRanges:array[0..2] of TCharacterRange;
  pCharRangeRegions:array of TGPRegion;
  i,count:integer;
  S:TD2FontStyle;
  B:TGPBitmap;
  G:TGPGraphics;
begin
  if not WordWrap then
    ARect.Right:=ARect.Left;
  if Length(AText)=0 then Exit;

  if FGraphics=nil then
  begin
    B:=TGPBitmap.Create(1,1,PixelFormat32bppARGB);
    G:=TGPGraphics.Create(B);
    G.SetSmoothingMode(QualityModeHigh);
    G.SetInterpolationMode(InterpolationModeHighQuality);
    G.SetPixelOffsetMode(PixelOffsetModeHalf);
    if FFont.ClearType then
      G.SetTextRenderingHint(TextRenderingHintClearTypeGridFit)
    else
      G.SetTextRenderingHint(TextRenderingHintAntiAlias);
    FGraphics:=G;
  end else
  begin
    G:=nil;
  end;

  if (frac(FMatrix.m11) <> 0) or (frac(FMatrix.m22) <> 0) then
    FGraphics.SetTextRenderingHint(TextRenderingHintAntiAlias);

  StringFormat:=TGPStringFormat.Create(StringFormatFlagsMeasureTrailingSpaces or StringFormatFlagsNoClip);
  if not WordWrap then
    StringFormat.SetFormatFlags(StringFormat.GetFormatFlags or StringFormatFlagsNoWrap);

  if not FGPFamily.IsStyleAvailable(d2StyleToGPStyle(FFont.Style)) then
  begin
    Font:=nil;
    for S:=d2FontRegular to d2FontStrikeout do
    begin
      if FGPFamily.IsStyleAvailable(d2StyleToGPStyle(S)) then
      begin
        Font:=TGPFont.Create(FGPFamily,(FFont.Size * 0.75 * FFontScale),d2StyleToGPStyle(S));
        Break;
      end;
    end;
    if Font=nil then
      Font:=TGPFont.Create(FGPFamily,(FFont.Size * 0.75 * FFontScale),d2StyleToGPStyle(FFont.Style));
  end else
    Font:=TGPFont.Create(FGPFamily,(FFont.Size * 0.75 * FFontScale),d2StyleToGPStyle(FFont.Style));

  case ATextAlign of
    d2TextAlignCenter:stringFormat.SetAlignment(StringAlignmentCenter);
    d2TextAlignNear:  stringFormat.SetAlignment(StringAlignmentNear);
    d2TextAlignFar:   stringFormat.SetAlignment(StringAlignmentFar);
  end;

  case AVTextAlign of
    d2TextAlignCenter: stringFormat.SetLineAlignment(StringAlignmentCenter);
    d2TextAlignNear:   stringFormat.SetLineAlignment(StringAlignmentNear);
    d2TextAlignFar:    stringFormat.SetLineAlignment(StringAlignmentFar);
  end;


  charRanges[0]:=MakeCharacterRange(0,Length(AText));
  StringFormat.SetMeasurableCharacterRanges(1,@charRanges);
  count:=StringFormat.GetMeasurableCharacterRangeCount;
  SetLength(pCharRangeRegions,count);
  if count > 0 then
    for i:=0 to count-1 do
      pCharRangeRegions[i]:=TGPRegion.Create;

  FGraphics.MeasureCharacterRanges(AText,-1,Font,GPRectFromRect(ARect),StringFormat,count,pCharRangeRegions);

  for i:=0 to count - 1 do
  begin
    pCharRangeRegions[i].GetBounds(GR,FGraphics);

    if i=0 then
      ARect:=d2Rect(GR.X,GR.Y,GR.X + GR.Width,GR.Y + GR.Height)  else
      ARect:=d2UnionRect(ARect,d2Rect(GR.X,GR.Y,GR.X + GR.Width,GR.Y + GR.Height));

  end;

  if count > 0 then
    for i:=0 to count-1 do
      pCharRangeRegions[i].Free;

  SetLength(pCharRangeRegions,0);

  Font.Free;
  StringFormat.Free;

  if G <> nil then
  begin
    G.Free;
    B.Free;
    FGraphics:=nil;
  end else
  begin
    if FFont.ClearType then
      FGraphics.SetTextRenderingHint(TextRenderingHintClearTypeGridFit) else
      FGraphics.SetTextRenderingHint(TextRenderingHintAntiAlias);
  end;
end;

function TD2CanvasGdiPlus.TextToPath(Path:TD2PathData; const ARect:TD2Rect; const AText:WideString; const WordWrap:boolean; const ATextAlign:TD2TextAlign;
   const AVTextAlign:TD2TextAlign=d2TextAlignCenter):boolean;
var
  StringFormat:TGPStringFormat;
  GPPath:TGPGraphicsPath;
  Bmp:TGPBitmap;
  FGraphics:TGPGraphics;
  Bits:Cardinal;
  i:integer;
  //SP,CP1,CP2:TD2Point;
  CP1,CP2:TD2Point;
  Data:TPathData;
  SavePoints:PGPPointF;
begin
  Result:=false;
  if (AText <> '') then
  begin
    if not FGPFamily.IsStyleAvailable(d2StyleToGPStyle(FFont.Style)) then Exit;

    Path.Clear;
    Bmp:=TGPBitmap.Create(1,1,1 * 4,PixelFormat32bppARGB,@Bits);
    FGraphics:=TGPGraphics.Create(Bmp);

    StringFormat:=TGPStringFormat.Create(0);
    if not WordWrap then
      StringFormat.SetFormatFlags(StringFormat.GetFormatFlags or StringFormatFlagsNoWrap or StringFormatFlagsMeasureTrailingSpaces);
    GPPath:=TGPGraphicsPath.Create;

    case ATextAlign of
      d2TextAlignCenter:stringFormat.SetAlignment(StringAlignmentCenter);
      d2TextAlignNear: stringFormat.SetAlignment(StringAlignmentNear);
      d2TextAlignFar:  stringFormat.SetAlignment(StringAlignmentFar);
    end;

    case AVTextAlign of
      d2TextAlignCenter:stringFormat.SetLineAlignment(StringAlignmentCenter);
      d2TextAlignNear: stringFormat.SetLineAlignment(StringAlignmentNear);
      d2TextAlignFar:  stringFormat.SetLineAlignment(StringAlignmentFar);
    end;

    GPPath.AddString(AText,-1,FGPFamily,d2StyleToGPStyle(FFont.Style),FFont.Size,GPRectFromRect(ARect),StringFormat);

    Data:=TPathData.Create;
    GPPath.GetPathData(Data);
    SavePoints:=Data.Points;

    i:=0;
    while i < Data.Count do
    begin
      if PByteArray(Data.Types)[i]=PathPointTypeStart then
      begin
        //SP:=d2Point(Data.Points^.X,Data.Points^.Y);
        Path.MoveTo(d2Point(Data.Points^.X,Data.Points^.Y));
      end;

      if PByteArray(Data.Types)[i] and PathPointTypeBezier=PathPointTypeBezier then
      begin
        CP1:=d2Point(Data.Points^.X,Data.Points^.Y);
        Inc(i);
        Inc(Data.Points);
        CP2:=d2Point(Data.Points^.X,Data.Points^.Y);
        Inc(i);
        Inc(Data.Points);
        Path.CurveTo(CP1,CP2,d2Point(Data.Points^.X,Data.Points^.Y));
      end;

      if PByteArray(Data.Types)[i] and PathPointTypeLine=PathPointTypeLine then
      begin
        Path.LineTo(d2Point(Data.Points^.X,Data.Points^.Y));
      end;

      if PByteArray(Data.Types)[i] and PathPointTypeCloseSubpath=PathPointTypeCloseSubpath then
      begin
        Path.ClosePath;
      end;

      Inc(i);
      Inc(Data.Points);
    end;
    Result:=true;

    Data.Points:=SavePoints;
    Data.Free;
    StringFormat.Free;
    GPPath.Free;


    FGraphics.Free;
    Bmp.Free;
  end
  else
    Result:=false;
end;


procedure TD2CanvasGdiPlus.DrawThumbnail(const ABitmap:TD2Bitmap; const Width,Height:single);
var
  scale:single;
begin
  UpdateBitmap(ABitmap);
  if ABitmap.Handle=0 then Exit;
  scale:=Width / ABitmap.Width;
  if FBitmap <> nil then
  begin
    Fgraphics.ScaleTransform(scale,scale);
    Fgraphics.DrawImage(TGPBitmap(ABitmap.Handle),0,0,ABitmap.Width,ABitmap.Height);
  end;
end;

procedure TD2CanvasGdiPlus.DrawBitmap(const ABitmap:TD2Bitmap; const SrcRect,DstRect:TD2Rect;
                                      const AOpacity:single; const HighSpeed:boolean=false);
var
  CM:TColorMatrix;
  ImageAttributes:TGPImageAttributes;
  //Pts:array [1..4] of TD2Point;
begin
  if HighSpeed then
    FGraphics.SetInterpolationMode(InterpolationModeNearestNeighbor)
  else
    FGraphics.SetInterpolationMode(QualityModeHigh);
  if (AOpacity < 1) then
  begin
    if (AOpacity=0) then Exit;
    CM:=ImgColorMatrix;
    CM[3][3]:=AOpacity;
    UpdateBitmap(ABitmap);
    if ABitmap.Handle=0 then Exit;
    ImageAttributes:=TGPImageAttributes.Create;
    ImageAttributes.SetColorMatrix(
      CM,
      ColorMatrixFlagsDefault,
      ColorAdjustTypeBitmap);
    FGraphics.DrawImage(TGPBitmap(ABitmap.Handle),MakeRect(DstRect.Left,DstRect.Top,DstRect.Right - DstRect.Left,DstRect.Bottom - DstRect.Top),
      SrcRect.Left,SrcRect.Top,SrcRect.Right - SrcRect.Left,SrcRect.Bottom - SrcRect.Top,
      UnitPixel,ImageAttributes);
    ImageAttributes.Free;
  end
  else
  begin
    UpdateBitmap(ABitmap);
    if ABitmap.Handle=0 then Exit;
    FGraphics.DrawImage(TGPBitmap(ABitmap.Handle),MakeRect(DstRect.Left,DstRect.Top,DstRect.Right - DstRect.Left,DstRect.Bottom - DstRect.Top),
      SrcRect.Left,SrcRect.Top,SrcRect.Right - SrcRect.Left,SrcRect.Bottom - SrcRect.Top,
      UnitPixel);
  end;
end;

procedure TD2CanvasGdiPlus.UpdateBitmap(ABitmap:TD2Bitmap);
begin

  if ABitmap=nil then Exit;
  if ABitmap.IsEmpty then Exit;

  if ABitmap.Handle=0 then
  begin
    ABitmap.Handle:=Cardinal(TGPBitmap.Create(ABitmap.Width,ABitmap.Height,
      ABitmap.Width * 4,PixelFormat32bppPARGB,PBYTE(ABitmap.StartLine)));
    ABitmap.NeedUpdate:=true;
    ABitmap.OnDestroyHandle:=DestroyBitmap;
  end;

  if (ABitmap.Width <> TGPBitmap(ABitmap.Handle).GetWidth) or
     (ABitmap.Height <> TGPBitmap(ABitmap.Handle).GetHeight) then
  begin
    TGPBitmap(ABitmap.Handle).Destroy;
    ABitmap.Handle:=Cardinal(TGPBitmap.Create(ABitmap.Width,ABitmap.Height,
      ABitmap.Width * 4,PixelFormat32bppPARGB,PBYTE(ABitmap.StartLine)));
    ABitmap.NeedUpdate:=true;
  end;

  ABitmap.NeedUpdate:=false;
end;

procedure TD2CanvasGdiPlus.DestroyBitmap(Sender:TObject);
begin
  if (Sender <> nil) then
  begin
    if (TD2Bitmap(Sender).Handle <> 0) then
      TGPBitmap(TD2Bitmap(Sender).Handle).Free;
    TD2Bitmap(Sender).Handle:=0;
  end;
end;

procedure TD2CanvasGdiPlus.DrawPath(const APath:TD2PathData; const ARect:TD2Rect; const AOpacity:single);
var
  B:TD2Rect;
  i:integer;
  W,H,NewW,NewH:single;
  CP1,CP2,CP,SP:TD2Point;
begin
  if not APath.IsEmpty then
  begin
    B:=APath.GetBounds;
    W:=d2RectWidth(B);
    H:=d2RectHeight(B);
    if W * H=0 then Exit;
    ApplyStroke(APath.GetBounds,AOpacity);
    NewW:=d2RectWidth(ARect);
    NewH:=d2RectHeight(ARect);
    i:=0;
    while i < Length(APath.PathData) do
    begin
      case APath.PathData[i].Kind of

        d2PathPointMoveTo:
          begin
            CP.X:=ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y:=ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
            SP:=CP;
          end;

        d2PathPointLineTo:
          begin
            FGraphics.DrawLine(FGPPen,CP.X,CP.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            CP.X:=ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y:=ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
          end;

        d2PathPointCurveTo:
          begin
            CP1:=d2Point(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            CP2:=d2Point(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            FGraphics.DrawBezier(FGPPen,CP.X,CP.Y,
              CP1.X,
              CP1.Y,
              CP2.X,
              CP2.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH
            );
            CP.X:=ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y:=ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
          end;

        d2PathPointClose:
          begin
            FGraphics.DrawLine(FGPPen,CP.X,CP.Y,SP.X,SP.Y);
          end;

      end;
      Inc(i);
    end;
  end;
end;

procedure TD2CanvasGdiPlus.FillPath(const APath:TD2PathData; const ARect:TD2Rect; const AOpacity:single);
var
  B:TD2Rect;
  i:integer;
  W,H,NewW,NewH:single;
  CP,CP1,CP2:TD2Point;
  P:TGPGraphicsPath;
begin
  if not APath.IsEmpty then
  begin
    B:=APath.GetBounds;
    W:=d2RectWidth(B);
    H:=d2RectHeight(B);
    if W * H=0 then Exit;
    NewW:=d2RectWidth(ARect);
    NewH:=d2RectHeight(ARect);
    P:=TGPGraphicsPath.Create;
    i:=0;
    while i < Length(APath.PathData) do
    begin
      case APath.PathData[i].Kind of

        d2PathPointMoveTo:
          begin
            CP.X:=ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y:=ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
            P.StartFigure;
          end;

        d2PathPointLineTo:
          begin
            P.AddLine(CP.X,CP.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            CP.X:=ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y:=ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
          end;

        d2PathPointCurveTo:
          begin
            CP1:=d2Point(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            CP2:=d2Point(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            P.AddBezier(CP.X,CP.Y,
              CP1.X,
              CP1.Y,
              CP2.X,
              CP2.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH
            );
            CP.X:=ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y:=ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
          end;

        d2PathPointClose:
          begin
            P.CloseFigure;
          end;

      end;
      Inc(i);
    end;

    IntFillPath(P,ARect,AOpacity);
    P.Free;
  end;
end;

function TD2CanvasGdiPlus.PtInPath(const APoint:TD2Point; const ARect:TD2Rect; const APath:TD2PathData):boolean;
var
  B:TD2Rect;
  i:integer;
  W,H,NewW,NewH:single;
  CP,CP1,CP2:TD2Point;
  P:TGPGraphicsPath;
begin
  Result:=false;
  if not d2PtInRect(APoint,ARect) then
    Result:=false
  else
  begin
    B:=APath.GetBounds;
    W:=d2RectWidth(B);
    H:=d2RectHeight(B);
    if W * H=0 then Exit;
    NewW:=d2RectWidth(ARect);
    NewH:=d2RectHeight(ARect);
    P:=TGPGraphicsPath.Create;
    i:=0;
    while i < Length(APath.PathData) do
    begin
      case APath.PathData[i].Kind of

        d2PathPointMoveTo:
          begin
            CP.X:=ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y:=ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
            P.StartFigure;
          end;

        d2PathPointLineTo:
          begin
            P.AddLine(CP.X,CP.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            CP.X:=ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y:=ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
          end;

        d2PathPointCurveTo:
          begin
            CP1:=d2Point(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            CP2:=d2Point(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            P.AddBezier(CP.X,CP.Y,
              CP1.X,
              CP1.Y,
              CP2.X,
              CP2.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH
            );
            CP.X:=ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y:=ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
          end;

        d2PathPointClose:
          begin
            P.CloseFigure;
          end;
      end;
      Inc(i);
    end;

    Result:=P.IsVisible(APoint.X,APoint.Y);

    P.Free;
  end;
end;              
